/**
 * Servi√ßo de Transcri√ß√£o de √Åudio
 * Usa Whisper local (GRATUITO) via @xenova/transformers
 */

import { pipeline } from "@xenova/transformers";
import fs from "fs";
import path from "path";
import { exec } from "child_process";
import { promisify } from "util";
import wavefilePackage from "wavefile";

const { WaveFile } = wavefilePackage;
const execAsync = promisify(exec);

class TranscriptionService {
  constructor() {
    this.model = null;
    this.loading = false;
    this.available = true; // Sempre dispon√≠vel (gratuito!)

    console.log(
      "‚úÖ [TRANSCRIPTION] Servi√ßo de transcri√ß√£o LOCAL inicializado (GRATUITO)"
    );
    console.log(
      "üí° [TRANSCRIPTION] Usando Whisper local - sem custos, sem limites!"
    );
  }

  /**
   * Inicializa o modelo Whisper local (lazy loading)
   */
  async initModel() {
    if (this.model) return this.model;

    if (this.loading) {
      // Aguardar se j√° est√° carregando
      while (this.loading) {
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
      return this.model;
    }

    try {
      this.loading = true;
      console.log("üîÑ [TRANSCRIPTION] Carregando modelo Whisper local...");
      console.log(
        "‚è≥ [TRANSCRIPTION] Primeira vez pode demorar ~5min (download do modelo MEDIUM)"
      );

      // Usar modelo Whisper MEDIUM para portugu√™s (m√°xima qualidade)
      this.model = await pipeline(
        "automatic-speech-recognition",
        "Xenova/whisper-medium"
      );

      console.log("‚úÖ [TRANSCRIPTION] Modelo Whisper MEDIUM carregado!");
      return this.model;
    } catch (error) {
      console.error("‚ùå [TRANSCRIPTION] Erro ao carregar modelo:", error);
      throw error;
    } finally {
      this.loading = false;
    }
  }

  /**
   * Transcreve um arquivo de √°udio usando Whisper local
   * @param {string} audioFilePath - Caminho completo do arquivo de √°udio
   * @param {string} language - C√≥digo do idioma (pt, en, es, etc)
   * @returns {Promise<{text: string, provider: string}>}
   */
  async transcribeAudio(audioFilePath, language = "pt") {
    if (!fs.existsSync(audioFilePath)) {
      throw new Error(`Arquivo de √°udio n√£o encontrado: ${audioFilePath}`);
    }

    try {
      console.log(`üé§ [TRANSCRIPTION] Transcrevendo √°udio: ${audioFilePath}`);
      console.log("üí∞ [TRANSCRIPTION] Usando Whisper LOCAL (100% gratuito!)");

      // Inicializar modelo se necess√°rio
      const transcriber = await this.initModel();

      // Verificar tamanho do arquivo
      const stats = fs.statSync(audioFilePath);
      const fileSizeMB = stats.size / (1024 * 1024);
      console.log(
        `üìä [TRANSCRIPTION] Tamanho do arquivo: ${fileSizeMB.toFixed(2)}MB`
      );

      // Converter √°udio para WAV 16kHz mono usando ffmpeg
      // WhatsApp usa Opus codec, ent√£o for√ßamos decodifica√ß√£o correta
      console.log("üîä [TRANSCRIPTION] Convertendo √°udio (Opus ‚Üí WAV)...");
      const tempWavPath = audioFilePath.replace(
        path.extname(audioFilePath),
        "_temp.wav"
      );

      try {
        // Primeiro: decodificar Opus e converter para WAV simples
        await execAsync(
          `ffmpeg -i "${audioFilePath}" -vn -ar 16000 -ac 1 -c:a pcm_s16le "${tempWavPath}" -y 2>&1`
        );
      } catch (error) {
        throw new Error(`Erro ao converter √°udio: ${error.message}`);
      }

      // Ler arquivo WAV
      const wavBuffer = fs.readFileSync(tempWavPath);
      const wav = new WaveFile(wavBuffer);

      // Converter para Float32Array normalizado
      const samples = new Float32Array(wav.getSamples(false, Float32Array));

      // Limpar arquivo tempor√°rio
      fs.unlinkSync(tempWavPath);

      // Transcrever usando Whisper local
      console.log("üé§ [TRANSCRIPTION] Transcrevendo com Whisper...");
      const startTime = Date.now();
      const result = await transcriber(samples, {
        language: language,
        task: "transcribe",
        return_timestamps: false,
      });

      const duration = ((Date.now() - startTime) / 1000).toFixed(2);
      console.log(`‚è±Ô∏è  [TRANSCRIPTION] Transcrito em ${duration}s`);

      const transcribedText = result.text || "";

      console.log("‚úÖ [TRANSCRIPTION] Transcri√ß√£o conclu√≠da com sucesso");
      console.log(
        `üìù [TRANSCRIPTION] Texto: "${transcribedText.substring(0, 100)}..."`
      );

      return {
        text: transcribedText,
        provider: "whisper-local",
        duration: parseFloat(duration),
      };
    } catch (error) {
      console.error("‚ùå [TRANSCRIPTION] Erro:", error.message);
      throw error;
    }
  }

  /**
   * Transcreve m√∫ltiplos √°udios em lote
   * @param {Array<{id: string, audioFilePath: string}>} audios
   * @param {string} language
   * @returns {Promise<Array<{id: string, transcription: string, error?: string}>>}
   */
  async transcribeBatch(audios, language = "pt") {
    const results = [];

    for (const audio of audios) {
      try {
        const transcription = await this.transcribeAudio(
          audio.audioFilePath,
          language
        );

        results.push({
          id: audio.id,
          transcription: transcription.text,
          duration: transcription.duration,
          provider: transcription.provider,
        });

        // Pequeno delay entre transcri√ß√µes
        await new Promise((resolve) => setTimeout(resolve, 500));
      } catch (error) {
        console.error(
          `‚ùå [TRANSCRIPTION] Erro ao transcrever ${audio.id}:`,
          error.message
        );
        results.push({
          id: audio.id,
          error: error.message,
        });
      }
    }

    return results;
  }

  /**
   * Verifica se o servi√ßo est√° dispon√≠vel
   */
  isAvailable() {
    return this.available;
  }

  /**
   * Retorna status do servi√ßo
   */
  getStatus() {
    return {
      available: this.available,
      provider: "whisper-local",
      model: "Xenova/whisper-medium",
      free: true,
      cost: "R$ 0,00",
    };
  }
}

// Singleton
const transcriptionService = new TranscriptionService();

export default transcriptionService;
